<!-- Generated by SpecStory -->

# Understanding the wizard tool development (2025-10-20 14:02Z)

_**User (2025-10-19 11:43Z)**_

Read @Details.md  and @DesignDocument.md to understand the `the-wizard` tool should be like.

The `the-wizard` is will based on this repo to develop. Current repo is a fundation of the tool and we should be able to complete by adding and modifying this repo. Do you understand?

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants me to read two documents (@Details.md and @DesignDocument.md) and understand what "the-wizard" tool should be like. They're indicating that the current repo is a foundation and the-wizard will be built by adding and modifying this repo.

Let me understand what I've read:

1. **Details.md** (in Chinese) - This is a detailed analysis of the current codebase (mcp-feedback-enhanced). It describes:
   - The 4-layer architecture (MCP Service Layer, Web UI Management Layer, Web Service Layer, Frontend Layer)
   - Components like WebUIManager, WebFeedbackSession, FastAPI routes, WebSocket communication
   - Environment detection (local, SSH, WSL)
   - Session management and feedback loops
   - Current functionality around collecting user feedback via web UI

2. **DesignDocument.md** - This is the technical design document for "The Wizard V1". It describes:
   - A "Spec-Then-Code" workflow system
   - RIPER-5 methodology (Read, Insight, Plan, Execute, Refine)
   - DAAS (Diagram-as-a-Spec) - using diagrams as binding specifications
   - Multi-stage workflow with explicit user approvals at each stage
   - Blueprint generation in Mermaid format
   - Test-first code generation
   - Pluggable workflow engine

The key insight is that Details.md describes the **current state** of the mcp-feedback-enhanced repo, while DesignDocument.md describes the **target state** - what "the-wizard" should become.

The current repo provides:
- MCP server infrastructure
- Web UI with WebSocket communication
- Session management
- User feedback collection mechanism
- Environment detection and browser launching

The target (The Wizard V1) needs:
- Multi-stage workflow (RIPER-5)
- Diagram editor with Mermaid rendering
- Test case management UI
- Strict stage progression with user confirmations


- Blueprint-driven code generation
- Pluggable workflow engine that allows flexible process customization

I see the project involves extending the existing infrastructure to create a more sophisticated workflow tool. The core challenge is transforming the current feedback-collection system into a comprehensive development workflow platform with advanced code generation and process management capabilities.</details></think>

---

Yes, I understand! Let me summarize what I've learned:

## Current State (mcp-feedback-enhanced)
The existing codebase provides a **foundation** with:
- **MCP server** (`server.py`) with `interactive_feedback` tool for AI-user interaction
- **4-layer architecture**: MCP Service → Web UI Management → Web Service (FastAPI/WebSocket) → Frontend
- **WebUIManager** singleton managing sessions and web server lifecycle
- **WebFeedbackSession** for tracking user feedback with WebSocket connections
- **Web UI** with HTML/JS/CSS for collecting feedback, managing prompts, session history
- **Environment detection** (local, SSH, WSL) with smart browser launching
- **Single active session** model with persistent web interface

## Target State (The Wizard V1)
The goal is to transform this into a **Spec-Then-Code workflow system** with:
- **RIPER-5 workflow**: Read → Insight → Plan → Execute → Refine stages
- **DAAS (Diagram-as-a-Spec)**: Using Mermaid diagrams as binding specifications
- **Multi-stage UI**:
  - Dual-pane Mermaid editor for blueprint design (Plan stage)
  - Editable test case table (Execute stage)
  - Code review and acceptance (Refine stage)
- **Strict gating**: User must explicitly confirm at each stage transition
- **Pluggable workflow engine** supporting multiple routines (though V1 focuses on spec-first)
- **Versioning**: Track diagram changes and user modifications

## Key Question Before Planning

Before I create a detailed implementation plan, I need to clarify the **scope and priority** of this initial work:

1. **What is the immediate goal for this phase?**
   - a) Build the complete RIPER-5 workflow end-to-end with all stages (Plan, Execute, Refine) and full UI
   - b) Start with foundational architecture (workflow engine, stage progression) and basic UI for one stage
   - c) Focus on specific high-priority features first (e.g., Mermaid diagram editor in Plan stage)
   - d) Create a working prototype demonstrating the core concept with simplified features

2. **Given the complexity described in Details.md about gaps between current and target state, should we prioritize:**
   - a) Backend workflow engine and state machine first, then build UI components
   - b) Frontend UI components (Mermaid editor, test table) first to validate UX
   - c) Full vertical slice of one complete workflow (e.g., Plan stage only, end-to-end)

---

_**User (2025-10-19 11:43Z)**_

We need to build news UI, and the workflow engine and all by finding gaps between the PRD/designDocumentation and this repo, and fill these gaps. So for now, we just need to create a prototype to show our idea works.

```
a) Backend workflow engine and state machine first, then build UI components
b) Frontend UI components (Mermaid editor, test table) first to validate UX
c) Full vertical slice of one complete workflow (e.g., Plan stage only, end-to-end)
```
I agree on your planned steps as above quoted.

I think this is difficult in one chat. So make a huge and detailed plan for implementation and write it down so that later we can keep on the plan.  

Are you ready? Ask me any questions before coding.

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants me to:
1. Create a comprehensive, detailed implementation plan
2. The plan should identify gaps between PRD/Design docs and current repo
3. Focus on building a prototype to validate the concept
4. The plan should be detailed enough to guide implementation over multiple sessions
5. They agree with the phased approach (backend → frontend → vertical slice)

Before creating the plan, I should ask clarifying questions to ensure the plan is accurate and actionable.

Key questions I should ask:
1. What constitutes "prototype" - which stages minimum?
2. Should we support all RIPER-5 stages or just the critical ones (Plan → Execute)?
3. Do we need the mode selection UI (4 quadrants) or can we skip to spec-first directly?
4. For the Mermaid editor - full dual-pane with live preview or simpler version?
5. Test case handling - full editable table or simplified list?
6. Should we integrate with existing session management or create parallel system?
7. What's the MVP for "showing the idea works"?

Let me ask the most critical questions to scope the prototype properly.</details></think>

---

Excellent! I'm ready to create a comprehensive implementation plan. Before I do, let me ask a few critical scoping questions to ensure the plan is accurate and actionable:

## Critical Scoping Questions

1. **For the prototype, which RIPER-5 stages should be fully functional?**
   - a) All 5 stages (Read, Insight, Plan, Execute, Refine) with simplified implementations
   - b) Core 3 stages: Plan (Mermaid editor) → Execute (tests + code) → Refine (manual review)
   - c) Just Plan → Execute to prove the DAAS concept works
   - d) Plan stage only, fully polished with diagram editing and confirmation

2. **Should the prototype include the initial mode selection UI (4-quadrant)?**
   - a) Yes, show mode selection UI but only Spec-First is functional
   - b) No, skip directly to Spec-First workflow when @TheWizard is invoked
   - c) Add a simple mode indicator but no selection UI

3. **For the Mermaid diagram editor in Plan stage, should we implement?**
   - a) Full dual-pane editor (source + live preview) with real-time rendering
   - b) Single pane with manual refresh for preview
   - c) Text editor only, preview in separate view/modal
   - d) Use existing UI with Mermaid rendering library, minimal custom editor

4. **Should we reuse existing WebFeedbackSession or create new WizardSession class?**
   - a) Extend WebFeedbackSession with new fields (phase, blueprint, etc.)
   - b) Create parallel WizardSession class specifically for multi-stage workflows
   - c) Create a wrapper/adapter that uses WebFeedbackSession internally

5. **For validation that "the idea works", what's the minimum success criteria?**
   - a) User can go through Plan → Execute → Accept Code with real AI interaction
   - b) Demo with mock AI responses showing the full UI flow
   - c) Just the workflow state machine working with basic UI placeholders

Please answer with the letter choices (e.g., "1-c, 2-b, 3-a, 4-a, 5-a"). I'll use these to create a focused, achievable plan.

---

_**User (2025-10-19 11:43Z)**_

1. All 5 stages are needed. But we can build one by one or starting from core stages. You can decided based on your best practice and best knowledge.

2. Yes, show mode selection UI but only Spec-First is functional.

3. Search about any open sourcing library we can directly use.

4. I don't know the difference. So you should analysis cons and pros for these 3 proposals and decided based on your best practice and best knowledge.

5. User can go through Plan → Execute → Accept Code with real AI interaction. This is not a hackathon, and I don't what a POC with lots of hardcoding. Instead, this is more likely a MLP (minimal lovable product)

---

_**Assistant**_

<think><details><summary>Thought Process</summary>Excellent! Now I have clear direction. Let me analyze the answers and make informed decisions:

1. **All 5 stages needed** - Build incrementally starting from core stages
2. **Mode selection UI** - Yes, with only Spec-First functional
3. **Mermaid editor** - Need to research libraries
4. **Session architecture** - Need to analyze pros/cons
5. **Success criteria** - Real AI interaction, MLP quality (not POC)

Let me think through the key decisions:

## Decision 4: Session Architecture Analysis

**Option A: Extend WebFeedbackSession**
Pros:
- Minimal code changes
- Reuses existing WebSocket handling, cleanup, state management
- Maintains compatibility with existing features (prompt manager, session history)

Cons:
- Risk of mixing concerns (simple feedback vs multi-stage workflow)
- WebFeedbackSession expects single feedback loop, may need awkward workarounds
- Fields like `feedback_result`, `feedback_completed` are semantically wrong for multi-stage

**Option B: Create parallel WizardSession**
Pros:
- Clean separation of concerns
- Purpose-built for multi-stage workflows
- Can have proper stage-specific fields (blueprint, tests, code)
- Easier to maintain and extend

Cons:
- More code to write initially
- Need to duplicate some WebSocket/cleanup logic
- WebUIManager needs to handle both session types

**Option C: Wrapper/Adapter**
Pros:
- Leverages existing infrastructure
- Clean abstraction layer
- Can gradually migrate

Cons:
- Added complexity with two layers
- May be over-engineering for V1

**DECISION**: I recommend **Option B - Create WizardSession** because:
- This is an MLP, not a quick hack - clean architecture matters
- Multi-stage workflow is fundamentally different from single feedback
- The codebase already has good patterns to follow
- Easier to test and maintain separately

I'll investigate the best tools for creating a Mermaid diagram editor. The key considerations are rendering reliability, editor functionality, and ease of integration. Mermaid.js stands out as the primary rendering solution, with CodeMirror 6 offering a lightweight, modern editing experience. If rapid prototyping is crucial, a simple textarea with syntax highlighting could provide a quick initial implementation. The goal is a clean, functional interface that supports diagram creation with minimal friction.

The implementation strategy follows a progressive, staged approach focusing on core functionality. The first phase establishes the foundational workflow, creating a state machine and wizard session that enables plan stage interactions. Critical early milestones include mode selection and a Mermaid editor allowing users to confirm their initial blueprint. Subsequent phases will expand capabilities, adding test case generation, code creation, and refinement mechanisms. Later stages concentrate on read/insight features and overall system polish, ensuring a comprehensive yet incrementally developed solution.

Logging and documentation represent the final refinement steps, ensuring system transparency and maintainability. These elements will capture critical process details and provide clear guidance for future development and user understanding.</details></think>

---

Perfect! Let me do a quick analysis and research, then create the comprehensive implementation plan.

---

<details>
            <summary>Searched web "mermaid.js live editor dual pane open source 2024" • **1** results</summary>

| Title | URL |
|-------|-----|
| Web Search Results | undefined |

</details>

---

<details>
            <summary>Searched web "CodeMirror 6 vs Monaco Editor lightweight text editor comparison" • **1** results</summary>

| Title | URL |
|-------|-----|
| Web Search Results | undefined |

</details>

---

<think><details><summary>Thought Process</summary>Good, I have some research info. Now let me create the comprehensive plan. Based on the research and user requirements:

1. **Mermaid Editor**: Use mermaid.js official library (widely adopted, well-maintained)
2. **Code Editor**: Use CodeMirror 6 (lightweight, modern, perfect for DSL editing) or simple textarea initially
3. **Session Architecture**: Create WizardSession (clean separation, purpose-built)
4. **Implementation order**: Core stages first (Plan → Execute → Refine), then add Read/Insight

Let me create a detailed, comprehensive plan that can guide the entire implementation.</details></think>

---

Now let me create a comprehensive, detailed implementation plan based on my analysis:

## Session Architecture Decision

**Analysis of Options:**

**A. Extend WebFeedbackSession:**
- Pros: Reuses WebSocket handling, cleanup logic, existing UI integration
- Cons: Single feedback loop design conflicts with multi-stage needs; fields like `feedback_completed` are semantically wrong; risk of breaking existing features

**B. Create WizardSession:**
- Pros: Clean separation, purpose-built for multi-stage; proper stage-specific fields (blueprint, tests, code); easier to test/maintain
- Cons: More initial code; need to implement WebSocket/cleanup patterns

**C. Wrapper/Adapter:**
- Pros: Gradual migration path
- Cons: Over-engineering for V1; added complexity

**DECISION: Option B - Create WizardSession**
For an MLP (not POC), clean architecture is critical. Multi-stage workflow is fundamentally different from single feedback collection.

## Mermaid Editor Technology Stack

**Research Findings:**
- **Mermaid rendering**: mermaid.js (official, 67k+ GitHub stars, CDN available)
- **Code editor options**:
  - Monaco Editor (VSCode's editor) - powerful but heavyweight (~3MB)
  - CodeMirror 6 - modern, lightweight (~200KB), excellent for DSL
  - Simple textarea - fastest to implement

**DECISION: Phase 1 uses textarea + mermaid.js for speed; Phase 5 upgrades to CodeMirror 6 for polish**

Now I'll create the detailed plan:

---



---

_**User (2025-10-21 15:40Z)**_

Implement the plan as specified. To-do's from the plan have already been created, do not create them again.

---

_**Assistant**_

<think><details><summary>Thought Process</summary>The user wants me to start implementing the comprehensive plan for The Wizard V1. The plan has been approved and todos are already created. I should start with Phase 1, beginning with the backend foundation.

Let me start by creating the directory structure and implementing the core components in order:

1. First, create the wizard directory structure
2. Implement WizardSession class
3. Implement WorkflowEngine
4. Implement RoutineRegistry
5. Implement WizardUIManager
6. Create prompt templates
7. Then move to frontend components

Let me begin with Phase 1 Backend tasks.</details></think>

---

Perfect! I'll start implementing **Phase 1: Foundation + Plan Stage** as specified in the plan. Let me begin by creating the directory structure and implementing the backend components first.

## Phase 1 Backend Implementation - Starting Now

---

```bash
mkdir -p src/mcp_feedback_enhanced/wizard/stages src/mcp_feedback_enhanced/wizard/prompts src/mcp_feedback_enhanced/wizard/routines
```

---
